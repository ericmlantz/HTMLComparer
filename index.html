<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HTML Element Comparator</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    textarea {
      width: 100%;
      height: 300px;
      margin: 10px 0;
      vertical-align: top;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px;
    }
    th {
      background: #f2f2f2;
    }
    .same { background-color: #d4edda; }
    .different { background-color: #f8d7da; }
    .missing { background-color: #fff3cd; }
    .section-header {
      margin-top: 30px;
      font-weight: bold;
      font-size: 18px;
    }
    mark { background: #ffeb3b; color: inherit; padding: 0 2px; border-radius: 2px; }
    /* Modal styles */
    .modal-backdrop { position: absolute; top: 0; left: 0; right: 0; background: rgba(0,0,0,.45); display: flex; align-items: flex-start; justify-content: center; z-index: 9999; padding: 24px 0; }
    .modal { width: min(900px, 92vw); background: #fff; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,.2); overflow: visible; }
    .modal-header { display:flex; align-items:center; justify-content: space-between; padding: 10px 14px; border-bottom: 1px solid #ddd; }
    .modal-header h3 { margin: 0; font-size: 18px; }
    .modal-header .close { border: 1px solid #ccc; background: #f8f8f8; border-radius: 4px; padding: 4px 8px; cursor: pointer; }
    .modal-body { padding: 12px 14px; display:flex; flex-direction:column; gap: 8px; overflow: visible; }
    .shadow-host-item textarea { width: 100%; }
    .modal-body textarea { width: 100%; box-sizing: border-box; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .modal-body .primary { background: #2563eb; color: #fff; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; }
    .modal-footer { padding: 10px 14px; border-top: 1px solid #ddd; text-align: right; }
    /* Keep large, readable inputs even with many hosts */
    #shadowHostList { max-height: none; overflow: visible; }
    #shadowTargetInput, #shadowOutput { min-height: 140px; }
  </style>
  <style>
    summary.dual-triangles {
      position: relative;
      cursor: pointer;
      list-style: none;
    }
    summary.dual-triangles::-webkit-details-marker {
      display: none;
    }
    summary.dual-triangles::before,
    summary.dual-triangles::after {
      content: "▶";
      color: #888;
      font-size: 0.9em;
      transition: transform 0.2s ease;
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
    }
    summary.dual-triangles::before {
      left: 0;
    }
    summary.dual-triangles::after {
      right: 0;
      margin-right: var(--right-indent, 0px);
    }
    details[open] > summary.dual-triangles::before,
    details[open] > summary.dual-triangles::after {
      transform: translateY(-50%) rotate(90deg);
    }
    /* Equal-width halves for Element 1 / Element 2 across tables */
table.simple-table,
table.attr-table,
table.child-attr-table,
table.child-tag-table,
table.child-text-table {
  table-layout: fixed;     /* obey colgroup widths */
  width: 100%;
  word-wrap: break-word;
  overflow-wrap: anywhere;
}

/* 3-col simple tables: Element1 | Element2 | Status */
table.simple-table col:nth-child(1) { width: 45%; }
table.simple-table col:nth-child(2) { width: 45%; }
table.simple-table col:nth-child(3) { width: 10%; }

/* 4-col attribute tables: Attribute | Element1 | Element2 | Status */
table.attr-table col:nth-child(1),
table.child-attr-table col:nth-child(1) { width: 20%; }
table.attr-table col:nth-child(2),
table.child-attr-table col:nth-child(2) { width: 40%; }
table.attr-table col:nth-child(3),
table.child-attr-table col:nth-child(3) { width: 40%; }
table.attr-table col:nth-child(4),
table.child-attr-table col:nth-child(4) { width: 10%; }

/* Even split header halves */
.header-split {
  display: flex;
  align-items: center;
  width: 100%;
  gap: 12px;
}
.header-split .left-half,
.header-split .right-half { flex: 1 1 0; }
.header-split .left-half { text-align: left; }
.header-split .right-half { text-align: right; }
  </style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<style>
  .code-editor {
    display: block;
    width: 100%;
    max-width: 100%;
    height: 300px;
    margin: 10px 0;
    padding: 10px;
    border: 1px solid #ccc;
    font-family: monospace;
    overflow-y: auto;
    overflow-x: hidden;
    white-space: pre-wrap;
    word-break: break-word;
    overflow-wrap: anywhere;
    background-color: #f5f5f5;
    box-sizing: border-box;
  }
  .editor-container {
    display: flex;
    flex-direction: row;
    gap: 20px;
  }
  /* Make the editable PRE wrap instead of forcing a single long line */
  pre.editor {
    white-space: pre-wrap !important;
    overflow-x: hidden !important;
    max-width: 100%;
  }
  pre.editor > code.code-editor {
    white-space: inherit !important; /* follow the PRE's wrapping */
    word-break: break-word;
    overflow-wrap: anywhere;
    display: block;
  }
</style>
</head>
<body>

  <h2>Compare Two HTML Elements</h2>

  <div class="editor-container">
    <div style="width: 50%;">
      <label for="element1" style="font-weight: bold;">Element 1</label>
      <pre class="editor"><code id="element1" class="code-editor language-markup" contenteditable="true" spellcheck="false" data-placeholder="Paste first HTML element here"></code></pre>
    </div>
    <div style="width: 50%;">
      <label for="element2" style="font-weight: bold;">Element 2</label>
      <pre class="editor"><code id="element2" class="code-editor language-markup" contenteditable="true" spellcheck="false" data-placeholder="Paste second HTML element here"></code></pre>
    </div>
  </div>

  <button onclick="compare()">Compare</button>
  <button id="shadowBtn" style="margin-left:8px;" onclick="openShadowModal()">Shadow Dom FuncStr Creation</button>

  <!-- Shadow Dom FuncStr Creation Modal -->
  <div id="shadowModal" class="modal-backdrop" style="display:none;">
    <div class="modal">
      <div class="modal-header">
        <h3>Shadow Dom FuncStr Creation</h3>
        <button class="close" onclick="closeShadowModal()">×</button>
      </div>
      <div class="modal-body">
        <label>Shadow root elements (outermost → innermost)</label>
        <div id="shadowHostList"></div>
        <div><button class="secondary" type="button" onclick="addShadowHost()">+ Add shadow root element</button></div>

        <label style="margin-top:12px;">Requested element HTML</label>
        <textarea id="shadowTargetInput" rows="5" placeholder="Paste the target element's HTML here"></textarea>

        <button class="primary" onclick="generateShadowFuncStr()" style="margin-top:12px;">Generate</button>

        <label style="margin-top:12px;">Generated function string</label>
        <textarea id="shadowOutput" rows="7" readonly></textarea>
      </div>
      <div class="modal-footer">
        <button onclick="closeShadowModal()">Close</button>
      </div>
    </div>
  </div>

  <div id="result"></div>

  <script>
    function compare() {
      const html1 = document.getElementById('element1').innerText.trim();
      const html2 = document.getElementById('element2').innerText.trim();
      const container1 = document.createElement('div');
      const container2 = document.createElement('div');

      container1.innerHTML = html1;
      container2.innerHTML = html2;

      // Automatically format and display the HTML content in the code editors
      if (container1.firstElementChild) {
        const formatted1 = formatHTML(container1.firstElementChild.outerHTML);
        const el1 = document.getElementById('element1');
        el1.textContent = formatted1;
      }
      if (container2.firstElementChild) {
        const formatted2 = formatHTML(container2.firstElementChild.outerHTML);
        const el2 = document.getElementById('element2');
        el2.textContent = formatted2;
      }
      Prism.highlightAll();

      const el1 = container1.firstElementChild;
      const el2 = container2.firstElementChild;

      if (!el1 || !el2) {
        document.getElementById('result').innerHTML = '<p style="color:red;">Please ensure both elements are valid and non-empty.</p>';
        return;
      }

      const tagComparison = compareSimple('Tag Name', el1.tagName.toLowerCase(), el2.tagName.toLowerCase());
      const textComparison = compareSimple('Inner Text', el1.textContent.trim(), el2.textContent.trim());
      const attrComparison = compareAttributes(el1, el2);
      const childComparison = compareChildren(el1, el2);

      let html = '';

      html += `<div style="text-align: center; font-size: 24px; font-weight: bold; margin-top: 40px;">Root Comparison Summary</div>`;
      html += renderSimple(tagComparison);
      html += renderSimple(textComparison);
      html += renderTable("Attribute Comparison", attrComparison);
      html += `<hr>`;

      html += `<div style="text-align: center; font-size: 24px; font-weight: bold; margin-top: 40px;">Child Structure Comparison</div>`;
      html += `<div style="display:flex; justify-content:center; margin: 12px 0 18px;">
                 <input id="filterInput" class="input" style="width: 60%; max-width: 700px; font-size: 18px; padding: 10px 12px;" placeholder="Search (e.g., div, class=btn, id=header, aria-label, or any text)">
               </div>`;
      html += renderChildComparison(childComparison);

      document.getElementById('result').innerHTML = html;
      Prism.highlightAll();
    }

    function compareSimple(label, value1, value2) {
      const status = value1 === value2 ? 'same' : 'different';
      return { label, value1, value2, status };
    }

    function compareAttributes(el1, el2) {
      if (!el1 || !el1.attributes || !el2 || !el2.attributes) return [];

      const allAttrs = new Set();
      for (const attr of el1.attributes) allAttrs.add(attr.name);
      for (const attr of el2.attributes) allAttrs.add(attr.name);

      const result = [];
      for (const name of allAttrs) {
        const val1 = el1.getAttribute(name);
        const val2 = el2.getAttribute(name);
        let status;
        if (val1 === val2) status = 'same';
        else if (val1 === null) status = 'missing in el1';
        else if (val2 === null) status = 'missing in el2';
        else status = 'different';

        result.push({ attribute: name, value1: val1, value2: val2, status });
      }
      return result;
    }

    function escapeHTML(str) {
      if (str == null) return '';
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function openingTag(el) {
      if (!el) return '<none>';
      const html = el.outerHTML || '';
      const m = html.match(/^<[^>]+>/);
      return m ? m[0] : `<${(el.tagName || '').toLowerCase()}>`;
    }

    function childHeader(c1, c2) {
      const mk = (el) => {
        const tag = openingTag(el);
        const truncated = tag.length > 180 ? tag.slice(0, 177) + '…>' : tag;
        return escapeHTML(truncated);
      };
      return { left: mk(c1), right: mk(c2) };
    }

    function enhanceClassRow(detail, val1, val2, status) {
      if (detail !== 'class') return null;
      const toTokens = (v) => (v || '').trim().split(/\s+/).filter(Boolean);
      const t1 = toTokens(val1);
      const t2 = toTokens(val2);
      const set2 = new Set(t2);
      const common = Array.from(new Set(t1.filter(x => set2.has(x))));

      const bolded = (tokens, commons) => tokens.map(tok => commons.includes(tok)
        ? `<b>${escapeHTML(tok)}</b>`
        : escapeHTML(tok)
      ).join(' ');

      const val1html = t1.length ? bolded(t1, common) : '<i>none</i>';
      const val2html = t2.length ? bolded(t2, common) : '<i>none</i>';

      let statusHTML = status;
      if (status !== 'same' && common.length) {
        statusHTML = `different,<br>except:` + common.map(c => `<br>- ${escapeHTML(c)}`).join('');
      }
      return { val1html, val2html, statusHTML };
    }

    // ---- ID comparison helpers ----
    function findCommonSubstrings(a, b, minLen = 3) {
      a = a || '';
      b = b || '';
      if (!a || !b) return [];
      const n = a.length, m = b.length;
      const dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(0));
      const found = new Set();
      for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
          if (a[i - 1] === b[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
            if (dp[i][j] >= minLen) {
              const sub = a.slice(i - dp[i][j], i);
              found.add(sub);
            }
          }
        }
      }
      // Keep only maximal substrings (remove any that are contained in a longer one)
      const arr = Array.from(found).sort((x, y) => y.length - x.length || x.localeCompare(y));
      const kept = [];
      for (const s of arr) {
        if (!kept.some(k => k.includes(s))) {
          kept.push(s);
        }
      }
      return kept;
    }

    function highlightSubstrings(str, subs) {
      if (!str) return '<i>none</i>';
      if (!subs || subs.length === 0) return escapeHTML(str);
      const marks = new Array(str.length).fill(false);
      for (const sub of subs) {
        if (!sub) continue;
        let idx = str.indexOf(sub);
        while (idx !== -1) {
          for (let k = idx; k < idx + sub.length; k++) marks[k] = true;
          idx = str.indexOf(sub, idx + 1);
        }
      }
      let out = '';
      let i = 0;
      while (i < str.length) {
        if (marks[i]) {
          let j = i;
          while (j < str.length && marks[j]) j++;
          out += '<b>' + escapeHTML(str.slice(i, j)) + '</b>';
          i = j;
        } else {
          let j = i;
          while (j < str.length && !marks[j]) j++;
          out += escapeHTML(str.slice(i, j));
          i = j;
        }
      }
      return out || '<i>none</i>';
    }

    function enhanceIdRow(detail, val1, val2, status) {
      if (detail !== 'id') return null;
      const commons = findCommonSubstrings(val1 || '', val2 || '', 3);
      const v1 = highlightSubstrings(val1 || '', commons);
      const v2 = highlightSubstrings(val2 || '', commons);
      let st = status;
      if (status !== 'same' && commons.length) {
        st = 'different,<br>except:' + commons.map(c => `<br>- ${escapeHTML(c)}`).join('');
      }
      return { val1html: v1 || '<i>none</i>', val2html: v2 || '<i>none</i>', statusHTML: st };
    }

    function compareChildren(el1, el2) {
      return compareNodeRecursive(el1, el2, 'root', 'root');
    }

    function compareNodeRecursive(el1, el2, path, header) {
      const results = [];

      const tag1 = el1?.tagName?.toLowerCase() || '<none>';
      const tag2 = el2?.tagName?.toLowerCase() || '<none>';

      let tagStatus = (tag1 === tag2) ? 'same' : 'different';

      results.push({
        path,
        header,
        type: 'tag',
        detail: 'Tag Name',
        val1: tag1,
        val2: tag2,
        status: tagStatus
      });

      const attrComparison = compareAttributes(el1 || {}, el2 || {}).map(attr => ({
        path,
        header,
        type: 'attribute',
        detail: attr.attribute,
        val1: attr.value1,
        val2: attr.value2,
        status: attr.status
      }));

      results.push(...attrComparison);

      const text1 = el1?.textContent?.trim() || '';
      const text2 = el2?.textContent?.trim() || '';
      const textStatus = text1 === text2 ? 'same' : 'different';

      results.push({
        path,
        header,
        type: 'text',
        detail: 'Text Content',
        val1: text1,
        val2: text2,
        status: textStatus
      });

      const children1 = Array.from(el1?.children || []);
      const children2 = Array.from(el2?.children || []);
      const max = Math.max(children1.length, children2.length);

      for (let i = 0; i < max; i++) {
        const c1 = children1[i];
        const c2 = children2[i];
        const childPath = `${path} > child[${i}]`;
        const childHdr = childHeader(c1, c2);
        results.push(...compareNodeRecursive(c1, c2, childPath, childHdr));
      }

      return results;
    }

    function renderSimple(comp) {
      const colorClass = comp.status === 'same' ? 'same' : 'different';
      return `
        <div class="section-header">${comp.label}</div>
        <table class="simple-table">
  <colgroup>
    <col><col><col>
  </colgroup>
          <thead><tr><th>Element 1</th><th>Element 2</th><th>Status</th></tr></thead>
          <tbody>
            <tr class="${colorClass}">
              <td>${comp.value1 || '<i>empty</i>'}</td>
              <td>${comp.value2 || '<i>empty</i>'}</td>
              <td>${comp.status}</td>
            </tr>
          </tbody>
        </table>
      `;
    }

    function renderTable(title, comparisons) {
      let html = `<div class="section-header">${title}</div><table class="attr-table"><colgroup><col><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Element 1</th><th>Element 2</th><th>Status</th></tr></thead><tbody>`;

      for (const { attribute, value1, value2, status } of comparisons) {
        let rowClass = '';
        if (status === 'same') rowClass = 'same';
        else if (status === 'different') rowClass = 'different';
        else rowClass = 'missing';

        let v1 = value1 || '<i>none</i>';
        let v2 = value2 || '<i>none</i>';
        let st = status;
        const enhanced = enhanceClassRow(attribute, value1, value2, status);
        if (enhanced) {
          v1 = enhanced.val1html;
          v2 = enhanced.val2html;
          st = enhanced.statusHTML;
        }
        // ---- ID enhancement ----
        const enhancedId = enhanceIdRow(attribute, value1, value2, st);
        if (enhancedId) {
          v1 = enhancedId.val1html;
          v2 = enhancedId.val2html;
          st = enhancedId.statusHTML;
        }

        html += `
          <tr class="${rowClass}">
            <td>${attribute}</td>
            <td>${v1}</td>
            <td>${v2}</td>
            <td>${st}</td>
          </tr>
        `;
      }

      html += '</tbody></table>';
      return html;
    }

    function renderChildComparison(comparisons) {
      const grouped = {};

      for (const entry of comparisons) {
        if (entry.path === 'root') continue;
        if (!grouped[entry.path]) grouped[entry.path] = [];
        grouped[entry.path].push(entry);
      }

      let html = '';

      for (const path in grouped) {
        const depth = path.split('>').length - 2;
        const indent = depth * 20;
        const h = (grouped[path][0] && grouped[path][0].header) ? grouped[path][0].header : null;
        let headerHTML;
        if (h && typeof h === 'object') {
          headerHTML = `
  <div class="header-split">
    <div class="left-half">
      <code class="language-markup" style="background: #f5f5f5; padding: 2px 6px; border-radius: 4px;">${h.left}</code>
    </div>
    <div class="right-half" style="padding-right: ${indent}px;">
      <code class="language-markup" style="background: #f5f5f5; padding: 2px 6px; border-radius: 4px;">${h.right}</code>
    </div>
  </div>
`;
        } else {
          const fallback = h || path;
          headerHTML = `<code class="language-markup">${fallback}</code>`;
        }
        html += `<details data-left="${(h && typeof h === 'object') ? h.left.replace(/"/g,'&quot;') : ''}" data-right="${(h && typeof h === 'object') ? h.right.replace(/"/g,'&quot;') : ''}" style="margin-left: ${indent}px;"><summary class="dual-triangles" style="--right-indent: ${indent}px; font-size: 1.1em; font-weight: bold; padding: 8px 24px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${headerHTML}</summary><div class="child-body" style="padding-right: ${indent}px;">`;

        const tagComp = grouped[path].find(e => e.type === 'tag');
        const textComp = grouped[path].find(e => e.type === 'text');
        const attrComps = grouped[path].filter(e => e.type === 'attribute');

        if (tagComp) {
          const rowClass = tagComp.status === 'same' ? 'same' : 'different';
          html += `
            <div class="section section-tag">
              <h3>Tag Name</h3>
              <table class="child-tag-table">
                <colgroup><col><col><col></colgroup>
                <thead><tr><th>Element 1</th><th>Element 2</th><th>Status</th></tr></thead>
                <tbody>
                  <tr class="${rowClass}">
                    <td>${tagComp.val1 || '<i>empty</i>'}</td>
                    <td>${tagComp.val2 || '<i>empty</i>'}</td>
                    <td>${tagComp.status}</td>
                  </tr>
                </tbody>
              </table>
            </div>
          `;
        }

        if (textComp) {
          const rowClass = textComp.status === 'same' ? 'same' : 'different';
          html += `
            <div class="section section-text">
              <h3>Text Content</h3>
              <table class="child-text-table">
                <colgroup><col><col><col></colgroup>
                <thead><tr><th>Element 1</th><th>Element 2</th><th>Status</th></tr></thead>
                <tbody>
                  <tr class="${rowClass}">
                    <td>${textComp.val1 || '<i>empty</i>'}</td>
                    <td>${textComp.val2 || '<i>empty</i>'}</td>
                    <td>${textComp.status}</td>
                  </tr>
                </tbody>
              </table>
            </div>
          `;
        }

        if (attrComps.length > 0) {
          html += `<div class="section section-attrs">`;
          html += `<h3>Attributes</h3>`;
          html += `<table class="child-attr-table"><colgroup><col><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Element 1</th><th>Element 2</th><th>Status</th></tr></thead><tbody>`;
          for (const { detail, val1, val2, status } of attrComps) {
            const rowClass = status === 'same' ? 'same' :
                             status === 'different' ? 'different' : 'missing';
            let v1 = val1 || '<i>none</i>';
            let v2 = val2 || '<i>none</i>';
            let st = status;
            const enhanced = enhanceClassRow(detail, val1, val2, status);
            if (enhanced) {
              v1 = enhanced.val1html;
              v2 = enhanced.val2html;
              st = enhanced.statusHTML;
            }
            const enhancedId = enhanceIdRow(detail, val1, val2, st);
            if (enhancedId) {
              v1 = enhancedId.val1html;
              v2 = enhancedId.val2html;
              st = enhancedId.statusHTML;
            }
            html += `
              <tr class="${rowClass}" data-attr="${detail}">
                <td>${detail}</td>
                <td>${v1}</td>
                <td>${v2}</td>
                <td>${st}</td>
              </tr>
            `;
          }
          html += '</tbody></table></div>';
        }

        html += `</div></details><hr>`;
      }

      return html;
    }
    Prism.highlightAll();
    // Placeholder logic for code editors
    ['element1', 'element2'].forEach(id => {
      const el = document.getElementById(id);
      el.innerHTML = `<span style="color: #aaa;">${el.dataset.placeholder}</span>`;
      el.addEventListener('focus', function handleFocus() {
        if (el.innerText.includes(el.dataset.placeholder)) {
          el.innerText = '';
          el.removeEventListener('focus', handleFocus);
        }
      });
    });

    // Helper to format HTML with indentation
    function formatHTML(html) {
      const tab = '  ';
      let indent = '';
      let result = '';

      html = html.replace(/>\s*</g, '><').trim(); // Minify to avoid splitting in wrong places
      const tokens = html.split(/(?=<)/g); // Split at start of each tag

      for (let token of tokens) {
        if (token.match(/^<\/\w/)) {
          indent = indent.slice(0, -tab.length);
        }
        result += indent + token.trim() + '\n';
        if (token.match(/^<\w[^>]*[^/]>/) && !token.includes('</')) {
          indent += tab;
        }
      }
      return result.trim();
    }

    // --- Safe highlighter helpers (preserve Prism markup) ---
    function unwrapMarks(root) {
      root.querySelectorAll('mark').forEach(m => {
        const text = document.createTextNode(m.textContent);
        m.replaceWith(text);
      });
    }

    function markMatchesInElement(el, query) {
      if (!query) return;
      const needle = query.toLowerCase();
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
      const toProcess = [];
      let node;
      while ((node = walker.nextNode())) {
        const src = node.nodeValue;
        const lc = src.toLowerCase();
        if (!lc || lc.indexOf(needle) === -1) continue;
        toProcess.push(node);
      }
      for (const textNode of toProcess) {
        let text = textNode.nodeValue;
        let lc = text.toLowerCase();
        if (!lc) continue;
        const frag = document.createDocumentFragment();
        let idx = lc.indexOf(needle);
        while (idx !== -1) {
          const before = text.slice(0, idx);
          const hit = text.slice(idx, idx + needle.length);
          if (before) frag.appendChild(document.createTextNode(before));
          const mark = document.createElement('mark');
          mark.textContent = hit;
          frag.appendChild(mark);
          text = text.slice(idx + needle.length);
          lc = text.toLowerCase();
          idx = lc.indexOf(needle);
        }
        if (text) frag.appendChild(document.createTextNode(text));
        textNode.replaceWith(frag);
      }
    }

    function applyChildFilter(q) {
      // Multiple tokens supported; AND logic across tokens.
      // Tokens can be: tag (e.g., div), class=value, attr, attr=value, or any free text.
      const tokens = (q || '').trim().split(/\s+/).filter(Boolean).map(t => t.toLowerCase());
      const detailsNodes = document.querySelectorAll('#result details');

      detailsNodes.forEach(d => {
        // Clear previous highlighting ONLY (keep Prism spans intact)
        unwrapMarks(d);

        // Reset visibility
        const secTag = d.querySelector('.section-tag');
        const secText = d.querySelector('.section-text');
        const secAttrs = d.querySelector('.section-attrs');
        if (secTag) secTag.style.display = 'none';
        if (secText) secText.style.display = 'none';
        if (secAttrs) {
          secAttrs.style.display = 'none';
          secAttrs.querySelectorAll('tbody tr').forEach(tr => tr.style.display = 'none');
        }

        if (tokens.length === 0) {
          // Show all when empty
          if (secTag) secTag.style.display = '';
          if (secText) secText.style.display = '';
          if (secAttrs) secAttrs.style.display = '';
          if (secAttrs) secAttrs.querySelectorAll('tbody tr').forEach(tr => tr.style.display = '');
          d.style.display = '';
          return;
        }

        const leftHeader = d.getAttribute('data-left')?.toLowerCase() || '';
        const rightHeader = d.getAttribute('data-right')?.toLowerCase() || '';

        let allTokensMatched = true;
        let anySectionVisible = false;
        const rowsToShow = new Set(); // union of matching rows across tokens

        for (const rawTok of tokens) {
          let matched = false;

          if (rawTok.startsWith('class=')) {
            const val = rawTok.slice(6);
            // class row contains value
            if (secAttrs) {
              secAttrs.querySelectorAll('tbody tr').forEach(tr => {
                const attr = (tr.getAttribute('data-attr') || '').toLowerCase();
                if (attr === 'class' && tr.innerText.toLowerCase().includes(val)) {
                  rowsToShow.add(tr);
                  matched = true;
                  // highlight cells with the value
                  markMatchesInElement(tr, val);
                }
              });
            }
            // header contains class and value
            if ((leftHeader.includes('class="') && leftHeader.includes(val)) ||
                (rightHeader.includes('class="') && rightHeader.includes(val))) {
              matched = true;
              anySectionVisible = true;
              d.querySelectorAll('summary code').forEach(code => markMatchesInElement(code, val));
            }
          } else if (rawTok.includes('=')) {
            // generic attr=value
            const [name, valueRaw] = rawTok.split('=');
            const nameL = name.trim();
            const valueL = (valueRaw || '').trim();
            if (secAttrs) {
              secAttrs.querySelectorAll('tbody tr').forEach(tr => {
                const attr = (tr.getAttribute('data-attr') || '').toLowerCase();
                if (attr === nameL && (!valueL || tr.innerText.toLowerCase().includes(valueL))) {
                  rowsToShow.add(tr);
                  matched = true;
                  // highlight attribute name and value
                  const nameCell = tr.querySelector('td:first-child');
                  if (nameCell) markMatchesInElement(nameCell, nameL);
                  if (valueL) markMatchesInElement(tr, valueL);
                }
              });
            }
            // header match too
            if ((leftHeader.includes(`${nameL}="`) && (!valueL || leftHeader.includes(valueL))) ||
                (rightHeader.includes(`${nameL}="`) && (!valueL || rightHeader.includes(valueL)))) {
              matched = true;
              anySectionVisible = true;
              d.querySelectorAll('summary code').forEach(code => markMatchesInElement(code, nameL));
              if (valueL) d.querySelectorAll('summary code').forEach(code => markMatchesInElement(code, valueL));
            }
          } else {
            // free text or tag
const maybeTag = rawTok;
const headerHasTag = leftHeader.includes(`<${maybeTag}`) || rightHeader.includes(`<${maybeTag}`);
const headerHasText = leftHeader.includes(maybeTag) || rightHeader.includes(maybeTag);
if (headerHasTag || headerHasText) {
  matched = true;
  if (secTag) secTag.style.display = '';
  anySectionVisible = true; // ensure node stays visible on header-only matches
  d.querySelectorAll('summary code').forEach(code => markMatchesInElement(code, maybeTag));
}
// Search ANY cell in ANY section for the text
            const allRows = d.querySelectorAll('.section-tag tbody tr, .section-text tbody tr, .section-attrs tbody tr');
            allRows.forEach(tr => {
              if (tr.innerText.toLowerCase().includes(maybeTag)) {
                rowsToShow.add(tr);
                matched = true;
                markMatchesInElement(tr, maybeTag);
              }
            });
          }

          if (!matched) allTokensMatched = false;
        }

        // Show accumulated rows
if (rowsToShow.size > 0) {
  rowsToShow.forEach(tr => {
    const section = tr.closest('.section'); // show the section wrapper itself
    if (section) section.style.display = '';
    tr.style.display = '';
  });
  anySectionVisible = true;
}

        // Ensure Tag/Text sections are visible if they contain shown rows
        const ensureVisible = (sel) => {
          const sec = d.querySelector(sel);
          if (!sec) return;
          const anyRow = sec.querySelector('tbody tr:not([style*="display: none"])');
          if (anyRow) sec.style.display = '';
        };
        ensureVisible('.section-tag');
        ensureVisible('.section-text');
        ensureVisible('.section-attrs');

        d.style.display = (allTokensMatched && anySectionVisible) ? '' : 'none';
      });
    }

    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'filterInput') {
        applyChildFilter(e.target.value);
      }
    });
    // --- Shadow Dom FuncStr modal controls ---
    function openShadowModal(){
      const modal = document.getElementById('shadowModal');
      modal.style.display = 'flex';
      const list = document.getElementById('shadowHostList');
      if (list && list.children.length === 0) {
        addShadowHost();
      }
    }
    function addShadowHost(preset){
      const list = document.getElementById('shadowHostList');
      if (!list) return;
      const wrapper = document.createElement('div');
      wrapper.className = 'shadow-host-item';
      wrapper.style.marginTop = '8px';
      wrapper.innerHTML = `
        <div style="display:flex; gap:8px; align-items:flex-start;">
          <textarea class="shadowHostTextarea" rows="3" placeholder="Paste one shadow host element HTML (e.g., <xweb-shellbar ...>)">${preset ? preset.replace(/`/g,'\`') : ''}</textarea>
          <button type="button" onclick="this.closest('.shadow-host-item').remove()">Remove</button>
        </div>`;
      list.appendChild(wrapper);
    }
    function closeShadowModal(){ document.getElementById('shadowModal').style.display='none'; }

    // --- Generate the jQuery + shadowRoot chain ---
    function generateShadowFuncStr(){
      const out = document.getElementById('shadowOutput');
      out.value = '';

      // Collect all provided shadow host elements
      const hostEls = Array.from(document.querySelectorAll('#shadowHostList .shadowHostTextarea'))
        .map(t => t.value.trim())
        .filter(Boolean)
        .map(html => { const d=document.createElement('div'); d.innerHTML = html; return d.firstElementChild; })
        .filter(el => !!el);

      if (hostEls.length === 0) {
        out.value = '// Add at least one shadow root element (outermost → innermost).';
        return;
      }

      // Prefer a specific selector for custom elements
      function bestSelector(el){
        const tag = (el.tagName || '').toLowerCase();
        const attrs = [
          ['id', el.getAttribute && el.getAttribute('id')],
          ['data-ui5-stable', el.getAttribute && el.getAttribute('data-ui5-stable')],
          ['data-help-id', el.getAttribute && el.getAttribute('data-help-id')],
        ];
        for (const [k, v] of attrs) {
          if (!v) continue;
          if (String(k).toLowerCase().includes('deepui')) continue; // never use deepui* attributes
          return `${tag}[${k}='${String(v).replace(/'/g, "\\'")}']`;
        }
        const cls = (el.getAttribute && (el.getAttribute('class')||'').trim().split(/\s+/).filter(Boolean)[0]) || '';
        if (cls) return `${tag}.${cls.replace(/[^\w-]/g,'')}`;
        return tag || '*';
      }

      // Build the chain based on provided hosts, outermost → innermost
      const lines = [];
      const shadowVars = [];
      hostEls.forEach((host, idx) => {
        const varName = idx===0 ? 'first' : `h${idx+1}`;
        const shadowVar = idx===0 ? 'firstShadow' : `${varName}Shadow`;
        const selector = bestSelector(host);
        if (idx === 0) {
          lines.push(`const ${varName} = wmjQuery("${selector}")[0];`);
        } else {
          const prevShadow = idx===1 ? 'firstShadow' : `h${idx}.shadowRoot`;
          lines.push(`const ${varName} = wmjQuery("${selector}", ${prevShadow})[0];`);
        }
        lines.push(`const ${shadowVar} = ${varName} && ${varName}.shadowRoot;`);
        shadowVars.push(`${shadowVar}`);
      });

      lines.push(shadowVars.join(', '));

      out.value = lines.join('\n');
    }
  </script>
</body>
</html>